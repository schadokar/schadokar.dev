[{"content":"","date":null,"permalink":"/tags/2021/","section":"Tags","summary":"","title":"2021"},{"content":"","date":null,"permalink":"/categories/2021/","section":"Categories","summary":"","title":"2021"},{"content":"","date":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories"},{"content":"In this post, I will try to document the different ways to run the javascript code.\nAs a beginner, you always need a simple way to run the code and test it.\nBrowser Console #The best way to test a piece of code is Browser console.\nOpen any browser except Internet Explorer as it doesn\u0026rsquo;t support many modern javascript feature.\nPress ctrl+shift+I or right click and select Inspect.\nIn the console tab you can write the javascript code and run.\nRun Offline using Nodejs #Install nodejs in your machine.\nWrite the javascript code in the .js file and run using node command.\nDemo #Create a file hello.js and paste the below code.\nconsole.log(\u0026#34;hello world!\u0026#34;); Open terminal or cmd in the location of hello.js.\nRun the code using node.\nnode hello.js Online Editor #There are many javascript online editors are available.\nFew of them are:\nPlaycode jsfiddle Replit - It supports dozens of language and framework. For javascript select nodejs. Javascript Playground By Stephen Grider #This is my way to go playground to test the js code.\nIt is created by Stephen Grider. JSPlayground\nThis is a open-source GitHub project which you can fork and run it locally.\nQuokka.js #This is a extension available in VS Code.\nThis is a real time js editor. With each line it shows what is the result.\nCheckout this short tutorial by Brad Traversy on Youtube.\nConclusion #This is my small list to test js code.\nIf you have other great tools or library, please ping me on twitter. I will update it here.\n","date":"April 15, 2021","permalink":"/posts/how-to-run-javascript-code/","section":"Posts","summary":"In this post, I will try to document the different ways to run the javascript code.","title":"How to Run Javascript Code"},{"content":"","date":null,"permalink":"/tags/javascript/","section":"Tags","summary":"","title":"javascript"},{"content":"","date":null,"permalink":"/categories/javascript/","section":"Categories","summary":"","title":"Javascript"},{"content":"","date":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts"},{"content":"","date":null,"permalink":"/","section":"schadokar.dev","summary":"","title":"schadokar.dev"},{"content":"","date":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags"},{"content":"","date":null,"permalink":"/tags/tips/","section":"Tags","summary":"","title":"tips"},{"content":"","date":null,"permalink":"/categories/2020/","section":"Categories","summary":"","title":"2020"},{"content":"","date":null,"permalink":"/tags/casual/","section":"Tags","summary":"","title":"casual"},{"content":"","date":null,"permalink":"/categories/casual/","section":"Categories","summary":"","title":"Casual"},{"content":"Finally, an another year ends with lots of memory and lost days. Unlike many years, this year was an exception.\nA deadly virus come out of China, may be one of the deadliest of the century. With this single event all the perceptions of life has changed.\nNot going in that. Lets starts.\nLike all the new year, in 2020 I also made few resolutions. Gym, join some salsa classes, have at least 4-5 trips, dubai expo 2020, reunion with few friends, 50 articles and a few more which I don\u0026rsquo;t remember.\nIt starts really well. In the beginning, I felt like this is the year when I will finally adhere to my resolutions.\nBut due to wuhan virus(aka corona) all the parameters turn 180 degree.\nA Summary # Wrote 35 Articles Wrote 1 ebook Playtime with Hyperledger Composer Switched to a new Company Deloitte as a Solution Advisor Published 1st article on freecodecamp Wrote 6-7 articles for a couple of other publications Talks @PuneGophers and @LondonGophers Reached 1000+ reputation on stackoverflow New skills: serverless with nodejs and golang using aws, oauth, ejs, grpc, nginx, Completed 1 udemy course on algorithms by stephen grider. Cooking skills on a new level: Dal bati, dhokla, cake, paneer(butter, masala, bhurji, shahi), upama, pasta. Started a new SaaS project. Initial phase complete. Still managed to meet with my 3 friends(Kesar, Shobhit, Vivek) Watched many tv series but from them these are worth watching: Money Heist, The Umbrella Academy, Dark, Dr. Stone(Anime), Mandalorian, Mirzapur, The Family Man, Special Ops, The Expanse, Panchayat And Last bye bye Long hairs There is lot more but don\u0026rsquo;t remember much :P\n","date":"January 1, 2021","permalink":"/posts/flashback-2020/","section":"Posts","summary":"Finally, an another year ends with lots of memory and lost days.","title":"Flashback 2020"},{"content":"","date":null,"permalink":"/tags/conversion/","section":"Tags","summary":"","title":"conversion"},{"content":"Decimal Number System #Decimal number system is the standard system for denoting integers and non-integers numbers.\nThis is also known as base 10 number system.\n0 1 2 3 4 5 6 7 8 9 Hexadecimal Number System #Hexadecimal (mostly used as hex) number system use 16 symbols. It is known as base 16 number system, where 10 symbols are same as decimal and value greater than 9 represent as A=10, B=11, C=12, D=13, E=14, F=15.\n0 1 2 3 4 5 6 7 8 9 A B C D E F Convert Hexadecimal to Decimal #Golang package strconv provides ParseInt and ParseUint to convert the string to the number in the respective base. Hexadecimal numbers are commonly use 0x or 0X in front of the number. It is only to avoid confusion.\nSyntax\nfunc ParseInt(s string, base int, bitSize int) (i int64, err error) package main import ( \u0026#34;fmt\u0026#34; \u0026#34;strconv\u0026#34; ) func main() { hexa := \u0026#34;F1\u0026#34; decimal, err := strconv.ParseInt(hexa, 16, 32) if err != nil { fmt.Println(err) } fmt.Printf(\u0026#34;Hexadecimal %s (base16) = Decimal %v (base10)\u0026#34;, hexa, decimal) } Output\nHexadecimal F1 (base16) = Decimal 241 (base10) The ParseUint is same as ParseInt but it takes only unsigned integers. To remove the 0x or 0X from the hex number, you can use slices.\nhexa := \u0026#34;0xfc\u0026#34; hexa = hexa[2:] Convert Decimal to Hexadecimal #The same strconv package provides FormatInt and FormatUint to convert the decimal number to a respective base number.\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;strconv\u0026#34; ) func main() { var decimal int64 = 252 hexa := strconv.FormatInt(decimal, 16) fmt.Printf(\u0026#34;Decimal %v (base10) = Hexadecimal %s (base16)\u0026#34;, decimal, hexa) } The FormatUint is same as FormatInt but it takes only unsigned integers.\nFor negative numbers use - minus sign.\n","date":"December 17, 2020","permalink":"/to-the-point/convert-hexadecimal-to-decimal-and-decimal-to-hexadecimal-in-golang/","section":"To-the-Points","summary":"Decimal Number System #Decimal number system is the standard system for denoting integers and non-integers numbers.","title":"Convert Hexadecimal to Decimal and Decimal to Hexadecimal in Golang"},{"content":"","date":null,"permalink":"/tags/golang/","section":"Tags","summary":"","title":"golang"},{"content":"","date":null,"permalink":"/categories/golang/","section":"Categories","summary":"","title":"Golang"},{"content":"","date":null,"permalink":"/categories/to-the-point/","section":"Categories","summary":"","title":"to-the-point"},{"content":"","date":null,"permalink":"/to-the-point/","section":"To-the-Points","summary":"","title":"To-the-Points"},{"content":"","date":null,"permalink":"/ebooks/","section":"Ebooks","summary":"","title":"Ebooks"},{"content":"Create a supplychain management project in Blockchain using Hyperledger Composer.\nDownload ","date":"September 23, 2020","permalink":"/ebooks/playtime-with-hyperledger-composer/","section":"Ebooks","summary":"Create a supplychain management project in Blockchain using Hyperledger Composer.","title":"Playtime with Hyperleder Composer"},{"content":"","date":null,"permalink":"/categories/article/","section":"Categories","summary":"","title":"Article"},{"content":"Validations are the key things to prevent the application\u0026rsquo;s unexpected behaviour. This is a list of basic validations every nodejs developer should know about.\nI will keep updating this article with new validation and best approaches.\ntypeof operator Syntax Number check Check NaN (not a number) Check if the number is finite String Check Boolean Check Undefined Check Null Check Null check using the Object Function check Object Check Check using the instanceof Array Check Buffer Check Conclusion typeof operator #Javascript provides a typeof operator. This operator returns the type of the variable.\nSyntax #typeof operand; typeof operand; Return Values of the typeof\nType Return Number \u0026ldquo;number\u0026rdquo; String \u0026ldquo;string\u0026rdquo; Boolean \u0026ldquo;boolean\u0026rdquo; Undefined \u0026ldquo;undefined\u0026rdquo; Null \u0026ldquo;object\u0026rdquo; Function \u0026ldquo;function\u0026rdquo; Object \u0026ldquo;object\u0026rdquo; There are a couple of other like BigInt(returns \u0026ldquo;bigint\u0026rdquo;) which introduced in ECMAScript 2020 and Symbol(returns \u0026ldquo;symbol\u0026rdquo;) which introduced in the ECMAScript 2015. Learn more\nNumber check #For all the numbers(integer, floating) and Infinity, it returns number.\nconst num1 = 12; // check if it is a number if (typeof num1 === \u0026#34;number\u0026#34;) { console.log(\u0026#34;It is a number\u0026#34;); } else { console.log(\u0026#34;It is not a number\u0026#34;); } // check for Infinity const num2 = Infinity; // check if it is a number if (typeof num2 === \u0026#34;number\u0026#34;) { console.log(\u0026#34;It is a number\u0026#34;); } else { console.log(\u0026#34;It is not a number\u0026#34;); } // check for string const num3 = \u0026#34;2\u0026#34;; // check if it is a number if (typeof num3 === \u0026#34;number\u0026#34;) { console.log(\u0026#34;It is a number\u0026#34;); } else { console.log(\u0026#34;It is not a number\u0026#34;); } Output\nIt is a number It is a number It is not a number Check NaN (not a number) #NaN is a property and its type is number. NaN is never equal to any number including NaN itself.\nNaN != NaN To check NaN, always use isNaN method.\nconst str = \u0026#34;js\u0026#34;; // check if it is not a number if (isNaN(str)) { console.log(\u0026#34;It is not a number\u0026#34;); } else { console.log(\u0026#34;It is a number\u0026#34;); } Output\nIt is not a number Check if the number is finite #isFinite method returns a boolean value if a number is finite or not.\nconst num1 = 12; // check if finite if (isFinite(num1)) { console.log(\u0026#34;Number is finite\u0026#34;); } else { console.log(\u0026#34;Number is not finite\u0026#34;); } const num2 = Infinity; // check if finite if (isFinite(num2)) { console.log(\u0026#34;Number is finite\u0026#34;); } else { console.log(\u0026#34;Number is not finite\u0026#34;); } Output\nNumber is finite Number is not finite String Check #// check for string const str = \u0026#34;2\u0026#34;; // check if it is a string if (typeof str === \u0026#34;string\u0026#34;) { console.log(\u0026#34;It is a string\u0026#34;); } else { console.log(\u0026#34;It is not a string\u0026#34;); } Output\nIt is a string Boolean Check #// check for boolean const bool = true; // check if it is a boolean if (typeof bool === \u0026#34;boolean\u0026#34;) { console.log(\u0026#34;It is a boolean\u0026#34;); } else { console.log(\u0026#34;It is not a boolean\u0026#34;); } // check for boolean const str = \u0026#34;str\u0026#34;; // check if it is a boolean if (typeof str === \u0026#34;boolean\u0026#34;) { console.log(\u0026#34;It is a boolean\u0026#34;); } else { console.log(\u0026#34;It is not a boolean\u0026#34;); } Output\nIt is a boolean It is not a boolean Undefined Check #// check for undefined const variable = undefined; // check if it is undefined if (typeof variable === \u0026#34;undefined\u0026#34;) { console.log(\u0026#34;It is undefined\u0026#34;); } else { console.log(\u0026#34;It is not undefined\u0026#34;); } Output\nIt is undefined Null Check #typeof null returns Object.\nCheck out why it returns Object.\n// check for null const variable = null; // check if it is a null if (variable === null) { console.log(\u0026#34;It is a null\u0026#34;); } else { console.log(\u0026#34;It is not a null\u0026#34;); } Output\nIt is a null Null check using the Object #function isNull(variable) { return Object.prototype.toString.call(variable) === \u0026#34;[object Null]\u0026#34;; } Function check #// check for function const variable = function (x, y) { return x + y; }; // check if it is a function if (typeof variable === \u0026#34;function\u0026#34;) { console.log(\u0026#34;It is a function\u0026#34;); } else { console.log(\u0026#34;It is not a function\u0026#34;); } Output\nIt is a function Object Check #There are multiple ways to check if the variable is an object or not.\n// check for Object const variable = { id: 12, }; // check if it is an Object if (typeof variable === \u0026#34;object\u0026#34;) { console.log(\u0026#34;It is an Object\u0026#34;); } else { console.log(\u0026#34;It is not an Object\u0026#34;); } Output\nIt is an Object Note: null is also an object\nCheck the object and not null.\n// check for Object and not null const variable = { id: 12, }; // check if it is an Object if (typeof variable === \u0026#34;object\u0026#34; \u0026amp;\u0026amp; variable !== null) { console.log(\u0026#34;It is an Object and not null\u0026#34;); } else { console.log(\u0026#34;It is not an Object\u0026#34;); } Output\nIt is an Object and not null Check using the instanceof #The instanceof operator returns boolean, it checks if the variable has a prototype property of a constructor exists in the prototype chain of an object.\nThe instanceof operator also takes care of the null object. It returns false to null.\n// check for Object const variable = { id: 12, }; // check if it is an Object if (variable instanceof Object) { console.log(\u0026#34;It is an Object\u0026#34;); } else { console.log(\u0026#34;It is not an Object\u0026#34;); } // check for Object const variable2 = null; // check if it is an Object if (variable2 instanceof Object) { console.log(\u0026#34;It is an Object\u0026#34;); } else { console.log(\u0026#34;It is not an Object\u0026#34;); } Output\nIt is an Object It is not an Object Array Check #An array is also an Object. Using typeof requires multiple validations to validate it.\nEmpty array is a true value.\nIn javascript Array class is a global object that is used in the construction in the arrays.\nArray class has many methods and one of them is isArray.\nisArray returns true if the variable is an array else false.\n// check for Array const arr = [\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;]; // check if it is an Array if (Array.isArray(arr)) { console.log(\u0026#34;It is an Array\u0026#34;); } else { console.log(\u0026#34;It is not an Array\u0026#34;); } // check for Array const arr2 = 12; // check if it is an Array if (Array.isArray(arr2)) { console.log(\u0026#34;It is an Array\u0026#34;); } else { console.log(\u0026#34;It is not an Array\u0026#34;); } Output\nIt is an Array It is not an Array Other alternatives to check the array.\n// conditions 1. arr.constructor === Array 2. arr instanceof Array 3. Object.prototype.toString.call(arr) === \u0026#39;[object Array]\u0026#39; Buffer Check #In the nodejs, Buffer class is in the global scope.\nBuffer class has an isBuffer method to check if the variable is buffer or not.\nBuffer objects are used to represent a fixed-length sequence of bytes. The Buffer class is a subclass of JavaScript\u0026rsquo;s Uint8Array class and extends it with methods that cover additional use cases. Node.js APIs accept plain Uint8Arrays wherever Buffers are supported as well.\n// check for Buffer const buf = Buffer.from(\u0026#34;Hello World\u0026#34;); // check if it is a Buffer if (Buffer.isBuffer(buf)) { console.log(\u0026#34;It is a Buffer\u0026#34;); } else { console.log(\u0026#34;It is not a Buffer\u0026#34;); } Output\nIt is a Buffer ⚠️ Buffer class is not available in the Javascript. Don\u0026rsquo;t try it in client-side application it will throw an error.\nConclusion #I\u0026rsquo;ll keep updating it with frequent validation a javascript or nodejs developer has to do every day.\nThanks for reading and please let me what else can be added in this.\n","date":"September 6, 2020","permalink":"/posts/basic-validations-every-nodejs-developer-should-know/","section":"Posts","summary":"Validations are the key things to prevent the application\u0026rsquo;s unexpected behaviour.","title":"Basic validations every nodejs developer should know"},{"content":"","date":null,"permalink":"/tags/good-practice/","section":"Tags","summary":"","title":"good-practice"},{"content":"","date":null,"permalink":"/categories/nodejs/","section":"Categories","summary":"","title":"Nodejs"},{"content":"","date":null,"permalink":"/tags/cloud/","section":"Tags","summary":"","title":"cloud"},{"content":"In this tutorial, we are going to create a golang serverless application and deploy it to the AWS cloud.\nTable of Content\nPrerequisites Getting Started Open hello/main.go Open serverless.yml Build the application Build Deploy Test the application Conclusion Prerequisites # Serverless Installed AWS account Connect AWS account to serverless All these are covered in detail in the last tutorial.\nGetting Started #Create a new directory hello-go-serverless.\nOpen the terminal inside the project.\nRun the below command to initiate the serverless application using aws-go-mod template.\nThis will create a basic scaffolding of the serverless project.\nserverless create --template aws-go-mod This template has created 2 application hello and world, and serverless.yml where serverless deployment configuration is defined. It also created a couple of deployment scripts.\nOpen hello/main.go #package main import ( \u0026#34;bytes\u0026#34; \u0026#34;context\u0026#34; \u0026#34;encoding/json\u0026#34; \u0026#34;github.com/aws/aws-lambda-go/events\u0026#34; \u0026#34;github.com/aws/aws-lambda-go/lambda\u0026#34; ) // Response is of type APIGatewayProxyResponse since we\u0026#39;re leveraging the // AWS Lambda Proxy Request functionality (default behavior) // // https://serverless.com/framework/docs/providers/aws/events/apigateway/#lambda-proxy-integration type Response events.APIGatewayProxyResponse // Handler is our lambda handler invoked by the `lambda.Start` function call func Handler(ctx context.Context) (Response, error) { var buf bytes.Buffer body, err := json.Marshal(map[string]interface{}{ \u0026#34;message\u0026#34;: \u0026#34;Go Serverless v1.0! Your function executed successfully!\u0026#34;, }) if err != nil { return Response{StatusCode: 404}, err } json.HTMLEscape(\u0026amp;buf, body) resp := Response{ StatusCode: 200, IsBase64Encoded: false, Body: buf.String(), Headers: map[string]string{ \u0026#34;Content-Type\u0026#34;: \u0026#34;application/json\u0026#34;, \u0026#34;X-MyCompany-Func-Reply\u0026#34;: \u0026#34;hello-handler\u0026#34;, }, } return resp, nil } func main() { lambda.Start(Handler) } This function is creating a JSON object using json.Marshal and then sent as a response.\nThe lambda package is initiating the Handler function and events package is used to create aws APIGatewayProxyResponse object.\nThis function is exposed as an API using the AWS APIGateway service. These APIs are configured in the serverless.yml file.\nCheck this to learn more about JSON in golang.\nOpen serverless.yml #In the provider section, the provider is aws, the runtime is go1.x, by default its region is us-east-1 and stage is dev. Using the staging option, you can deploy the project in different environments like dev, prod or test.\nUpdate the provider section.\nprovider: name: aws runtime: go1.x stage: dev region: us-east-1 You don\u0026rsquo;t have to if you\u0026rsquo;re okay with the defaults. It is just good practice.\nIn the package section, it is configuring what to include and exclude in the lambda function deployment.\nIt is excluding all the files except bin folder. After building the application, the function binary will save in the bin folder.\npackage: exclude: - ./** include: - ./bin/** In the functions, bin/hello is the entry point of hello function. The function can be triggered using the hello route. After deployment, it will create a new route in the AWS API gateway and link it to the AWS lambda function in which hello function will deploy.\nfunctions: hello: handler: bin/hello events: - http: path: hello method: get world function is the same as hello.\nYou can use the Makefile for the below steps. It is a deployment script, which will run all the below steps for you.\nBuild the application #Open the terminal in the project and execute the gomod.sh file.\nWindows User\nsh gomod.sh Linux User or other UNIX based OS users First, make it executable and then run it.\nchmod u+x gomod.sh ./gomod.sh This will initiate go modules go.mod in the project and add all the project dependencies in it. It is similar to the package.json in the node.js.\nBuild #Create binaries of hello and world application for Linux OS.\nexport GO111MODULE=on env GOOS=linux go build -ldflags=\u0026#34;-s -w\u0026#34; -o bin/hello hello/main.go env GOOS=linux go build -ldflags=\u0026#34;-s -w\u0026#34; -o bin/world world/main.go It will generate binaries of the application and save them in the bin folder.\nDeploy #I am assuming that you have an AWS account and it is connected to the Serverless.\nIf you not check this to setup.\nRun the below command to deploy it to the AWS lambda.\nserverless deploy You can use sls for serverless. It is a shorthand notation.\nTest the application #Copy the endpoint from the deployment output and either try it on a browser or use the curl command to check.\n$ curl https://616fr92us4.execute-api.us-east-1.amazonaws.com/dev/hello Output\n% Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed 100 70 100 70 0 0 63 0 0:00:01 0:00:01 --:--:-- 63 {\u0026#34;message\u0026#34;:\u0026#34;Go Serverless v1.0! Your function executed successfully!\u0026#34;} World\n$ curl https://616fr92us4.execute-api.us-east-1.amazonaws.com/dev/world Output\n% Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed 100 69 100 69 0 0 76 0 --:--:-- --:--:-- --:--:-- 76 {\u0026#34;message\u0026#34;:\u0026#34;Okay so your other function also executed successfully!\u0026#34;} Conclusion #Serverless is the perfect companion for the golang. In the upcoming tutorials, we will integrate multiple services in serverless like DB, SNS etc.\nThanks for reading.\nCover is designed in Canva\n","date":"August 10, 2020","permalink":"/posts/create-a-serverless-application-in-golang-with-aws/","section":"Posts","summary":"In this tutorial, we are going to create a golang serverless application and deploy it to the AWS cloud.","title":"Create a Serverless Application in Golang With AWS"},{"content":"","date":null,"permalink":"/categories/serverless/","section":"Categories","summary":"","title":"Serverless"},{"content":"","date":null,"permalink":"/tags/aws/","section":"Tags","summary":"","title":"aws"},{"content":"","date":null,"permalink":"/categories/cloud/","section":"Categories","summary":"","title":"Cloud"},{"content":"Serverless computing is a cloud computing execution model in which the cloud provider runs the server, and dynamically manages the allocation of machine resources. Pricing is based on the actual amount of resources consumed by an application, rather than on pre-purchased units of capacity. - Wikipedia\nIn simple language, serverless means pay only for what you use. You might think there is already a Pay-as-you-go model provided by the cloud providers.\nLet me rephrase it, serverless means pay only for what you execute. Serverless doesn\u0026rsquo;t mean that there will be no server, it means that you don\u0026rsquo;t have to worry about the server and its setup. Focus on the application logic or in our programming terminology only focus on writing the code or functions.\nYou can deploy these individual functions to the cloud and whenever this function will execute, only for that execution you will be charged.\nIsn\u0026rsquo;t it great? 😃\nServerless computing concept was first introduced in 2010. AWS Lambda, introduced by Amazon in 2014, was the first public cloud infrastructure vendor with an abstract serverless computing offering.\nWith the popularity of microservice architecture, serverless is the best option in terms of economics and reliability.\nServerless Framework # Serverless is an open-source project, introduced in 2015. Serverless provides features to deploy the function to almost every cloud. For ex. AWS, Azure, GCP. Using serverless you can access and manage other cloud services like storage, API gateway, DB etc.\nDon\u0026rsquo;t get confused. Serverless computing or serverless is a concept, while there is a framework or tool also name as serverless.\nGetting Started #To install the serverless, first install the nodejs in the machine.\nGo to nodejs.\nInstall serverless #Run the below npm command.\nnpm install --global serverless Create a nodejs application and deploy on AWS #Create a new directory hello-serverless.\nOpen the terminal in the directory and run the below command.\nserverless create --template aws-nodejs This template has created 2 files, handler.js where the function is defined and serverless.yml where serverless deployment configuration is defined.\nOpen handler.js.\nThis is a simple function which will return a message.\nmodule.exports.hello = async (event) =\u0026gt; { return { statusCode: 200, body: JSON.stringify( { message: \u0026#34;Go Serverless v1.0! Your function executed successfully!\u0026#34;, input: event, }, null, 2 ), }; }; Create an API endpoint for hello function #Open serverless.yml.\nIn the provider section, it is aws and by default, its region is us-east-1. It also provides a staging option, you can deploy the project in a different environment like dev, prod or test.\nUpdate the provider section:\nprovider: name: aws runtime: nodejs12.x stage: dev region: us-east-1 In the functions, create a new route for the hello function. It will create a new route in the AWS API gateway and link it to the AWS lambda function in which hello function will deploy.\nUpdate the function section:\nfunctions: hello: handler: handler.hello events: - http: path: v1/hello method: get We have created a http event of GET request type and v1/hello route.\nThe function is ready and configured.\nFor deploying it, we need to connect AWS account with the serverless.\nCreate an AWS account #Create an account in AWS cloud if you don\u0026rsquo;t have.\nOpen the AWS account and go to IAM.\nCreate a new user with Administrator Access. Using this user, the serverless can create the lambda function and other required resources on the AWS cloud.\nCreate a new User #Enter the user name and select the Programmatic access.\nClick Next.\nPermissions #Select the AdministratorAccess.\nThis is only for the education purpose, in production configure the access according to the requirement.\nNow, Click Next till review tab and Create the User.\nDownload the credentials. If you misplace this, then you have to recreate it again. Save it properly. Keep it handy, we need it in the next step.\nDeploy to AWS #Open terminal in the project directory.\nRun the below command to connect serverless CLI to AWS account.\nserverless config credentials --provider aws --key \u0026lt;ACCESS KEY\u0026gt; --secret \u0026lt;Secret Access key\u0026gt; ❗ Don\u0026rsquo;t use the shorthand -s for secret, it is reserved keyword and will throw a serverless error Invalid stage name.\nUse the below command to deploy the function to the AWS.\nserverless deploy You can use sls for serverless. It is a shorthand notation.\nOnce, it deployed successfully, you will get output similar to this.\nTest the function #Copy the endpoint from the deploy output. https://dtv6erp3g3.execute-api.us-east-1.amazonaws.com/dev/v1/hello\nTry it in browser. Conclusion #Serverless computing is economical and reliable but we have should not follow it blindly. All the technologies work best up to a certain limit if we try it beyond that instead of helping it will increase your workload.\nWe should use it according to the use case and requirement.\nThe serverless tool is great. Even for a beginner, the learning curve is smooth. In the upcoming tutorials, you will get more projects to play with serverless.\nThanks for reading. 😃\nCover is designed in Canva\n","date":"August 9, 2020","permalink":"/posts/create-your-first-serverless-application/","section":"Posts","summary":"Serverless computing is a cloud computing execution model in which the cloud provider runs the server, and dynamically manages the allocation of machine resources.","title":"Create your first Serverless application"},{"content":"","date":null,"permalink":"/tags/lambda/","section":"Tags","summary":"","title":"lambda"},{"content":"","date":null,"permalink":"/tags/serverless/","section":"Tags","summary":"","title":"serverless"},{"content":"","date":null,"permalink":"/tags/jwt/","section":"Tags","summary":"","title":"jwt"},{"content":"In this tutorial, we will learn how to secure the APIs using the JWT authentication in Golang.\nIn any application, APIs are the bridge between two services. These services can be anything, like a backend service or a frontend service.\nTo secure the application, bridge security is important.\nJWT is a JSON web token. In which, a token is generated by 1 service and shared with another service. Whenever the 2nd service make a request to the 1st service, it will send the token with the request. Then the first service will validate if the token is valid or not, in this way, it is validating if it is requested from the genuine service or not.\nFor Ex. In a web application, when a user login, the content is unique and personalized according to him. Even when you reload the page or close the browser, when you will open it, it is still logged in.\nHow the application knows this? As every time it is making a new request to the server and it is not asking to login user with each request. It is the token which is saved in the browser. It can be saved in the cookie or in the browser storage. These tokens are not limited to the JWT, there are many alternatives available.\nNext time, when you login in to any application, check the cookie and storage. Then clear the cookies and storage of that site and reload it. It will ask you for sign in again. 😃\nWhat is JWT? #JWT stands for JSON Web Token. JWT represents a claim between two parties which is shared in a JSON format.\nIn simple words, it is similar to your ID cards. In school, college, office etc places this ID card is provided by the organization to you to authenticate yourself whenever you enter the premises. 🧐\nJSON Web Token (JWT) is an open standard (RFC 7519) that defines a compact and self-contained way for securely transmitting information between parties as a JSON object. This information can be verified and trusted because it is digitally signed. JWTs can be signed using a secret (with the HMAC algorithm) or a public/private key pair using RSA or ECDSA.\nHow JWT works? #The JWT structured in three parts:\nHeader: It identify which algorithm is used Payload: The information Signature: The encryption of the information by a Secret Key using the Algorithm The three parts are separated by the dot(.).\nFor Ex: Header.Payload.Signature\nLet\u0026rsquo;s understand it with an example. Suppose the Header is algorithm1 and algorithm1 is the below equation.\nSignature = Payload * SecretKey Then, the Payload is 11 and the SecretKey is 5.\nWhen the Payload and SecretKey is passed to the algorithm1 it will generate a unique Signature.\nSignature = Payload * SecretKey = 11 * 5 = 55 The Signature is 55.\nThen the JWT token will look like this.\nalgorithm1.11.55 This JWT token will be shared with the requested party. After this whenever this party raise a request to this party, it will also share this token to authenticate itself.\nWhen the first party receives the request with the token, it will first validate the token before processing the request.\nAs all the details are available in the token it is very easy task for the party to validate the token. It will take the Payload and passed it to the Header (algorithm1) using the SecretKey which it already have to generate the Signature. Then it will compare the token Signature with the generated Signature, if it matched Voila go ahead with the request else decline the request. 🔎\nThe actual JWT Token looks like this.\neyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYW1lIjoiSSBhbSBJcm9uIE1hbi4ifQ.li-FDEyAdayupFIS5P2EKexN-Rm_SWe4LXO9Xjyja4o Take a quick look and you can see the token is divided in 3 parts:\nHeader: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9 Payload: eyJuYW1lIjoiSSBhbSBJcm9uIE1hbi4ifQ Signature: li-FDEyAdayupFIS5P2EKexN-Rm_SWe4LXO9Xjyja4o The Header and Payload are base64 encoded.\npackage main import ( b64 \u0026#34;encoding/base64\u0026#34; \u0026#34;fmt\u0026#34; ) func main() { header := \u0026#34;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9\u0026#34; payload := \u0026#34;eyJuYW1lIjoiSSBhbSBJcm9uIE1hbi4ifQ\u0026#34; decodedHeader, _ := b64.StdEncoding.DecodeString(header) decodedPayload, _ := b64.StdEncoding.DecodeString(payload) fmt.Printf(\u0026#34;Decoded Header: %s\\nDecoded Payload:%s\u0026#34;, decodedHeader, decodedPayload) } Try it\nOutput\nDecoded Header: {\u0026#34;alg\u0026#34;:\u0026#34;HS256\u0026#34;,\u0026#34;typ\u0026#34;:\u0026#34;JWT\u0026#34;} Decoded Payload:{\u0026#34;name\u0026#34;:\u0026#34;I am Iron Man.\u0026#34;} The algorithm in Header is HS256 which is used to sign the Payload.\nThe Payload is a JSON object with a key as name and value as I am Iron Man.\nTo sign this payload, the SecretKey is secretKey. 😅\nGetting Started #We are going to create a simple web application. In this application, there will be 2 routes, first login and second dashboard.\nPrerequisites # Go v1.11 or greater (I am using Go v1.14) Code Editor (For ex. VS Code, Atom) Postman - to test the APIs. Curl commands can also be used. Project Structure #Create a new project go-jwt-app.\nOpen the terminal inside the go-jwt-app and initialize the go modules using the below command.\ngo mod init go-jwt-app Go modules is a dependency manager or a package manager. It will track all the dependencies used in the project with their version. You can read more about it here.\nInstall the dependencies #There are 3 packages used in this Project.\nGorilla/mux: It is a feature rich package to create the APIs and server. jwt-go: It is a Golang implementation of JSON Web Token(JWT). Using this package, we can create and verify the JWT tokens. godotenv: Using this package, we can access the .env file in which environment variables can be saved. go get github.com/gorilla/mux go get github.com/dgrijalva/jwt-go go get github.com/joho/godotenv Environment Variable #Create a new .env file and paste the below code in it.\nSECRET_KEY=secret007 Using the godotenv package, we can read the SECRET_KEY.\nJWT implementation #In this section, we can divide the process in modules to understand clearly.\nCreate Server and Routes #package main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; ... \u0026#34;github.com/gorilla/mux\u0026#34; ) func main() { r := mux.NewRouter() r.HandleFunc(\u0026#34;/login\u0026#34;, login).Methods(\u0026#34;POST\u0026#34;) r.HandleFunc(\u0026#34;/me\u0026#34;, dashboard).Methods(\u0026#34;GET\u0026#34;) fmt.Println(\u0026#34;Starting server on the port 8000...\u0026#34;) log.Fatal(http.ListenAndServe(\u0026#34;:8000\u0026#34;, r)) } First, create a new instance of mux router using the mux.NewRouter() method.\nUsing the HandleFunc create 2 routes. /login as a POST request and /me as a GET request.\nThe /login endpoint will execute login function and /me will execute the dashboard function.\nCreate a new JWT Token #In this login function, when a user will enter its username and password, it will first validate if the user registered or not. To validate, we will create a local user db using the map.\nOn successful, verification it will generate a Token using the jwt-go package and send to the request as a response.\nTo generate the JWT token, we are going to use the HS256 algorithm.\npackage main import ( \u0026#34;encoding/json\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;os\u0026#34; \u0026#34;strings\u0026#34; \u0026#34;time\u0026#34; jwt \u0026#34;github.com/dgrijalva/jwt-go\u0026#34; \u0026#34;github.com/gorilla/mux\u0026#34; \u0026#34;github.com/joho/godotenv\u0026#34; ) // Secret key to uniquely sign the token var key []byte // Credential User\u0026#39;s login information type Credential struct{ Username string `json:\u0026#34;username\u0026#34;` Password string `json:\u0026#34;password\u0026#34;` } // Token jwt Standard Claim Object type Token struct { Username string `json:\u0026#34;username\u0026#34;` jwt.StandardClaims } // Create a dummy local db instance as a key value pair var userdb = map[string]string{ \u0026#34;user1\u0026#34;: \u0026#34;password123\u0026#34;, } // assign the secret key to key variable on program\u0026#39;s first run func init() { // Load the .env file to access the environment variable err := godotenv.Load() if err != nil { log.Fatal(\u0026#34;Error loading .env file\u0026#34;) } // read the secret_key from the .env file key = []byte(os.Getenv(\u0026#34;SECRET_KEY\u0026#34;)) } // login user login function func login(w http.ResponseWriter, r *http.Request) { // create a Credentials object var creds Credential // decode json to struct err := json.NewDecoder(r.Body).Decode(\u0026amp;creds) if err != nil { w.WriteHeader(http.StatusBadRequest) return } // verify if user exist or not userPassword, ok := userdb[creds.Username] // if user exist, verify the password if !ok || userPassword != creds.Password { w.WriteHeader(http.StatusUnauthorized) return } // Create a token object and add the Username and StandardClaims var tokenClaim = Token { Username: creds.Username, StandardClaims: jwt.StandardClaims{ // Enter expiration in milisecond ExpiresAt: time.Now().Add(10 * time.Minute).Unix(), }, } // Create a new claim with HS256 algorithm and token claim token := jwt.NewWithClaims(jwt.SigningMethodHS256, tokenClaim ) tokenString, err := token.SignedString(key) if err != nil { log.Fatal(err) } json.NewEncoder(w).Encode(tokenString) } In the init function, using the godotenv package load the .env file to read the SECRET_KEY.\nCheck this to learn more on environment variables in Golang.\nIn the login function, first read the request body to get the username and password. The request body is in JSON format. Read the JSON using the encoding/json package.\nCheck this to learn more on how to use JSON in Golang.\nIn the userdb, we have created a dummy user. It will validate the user using the userdb.\nOn successful user validation, create a Token object. The Token object has a Username and a StandardClaims. In the StandardClaims, you can define the validity of the token.\nThe StandardClaims takes Unix time.\nCreate a new Claims, with the HS256 algorithm and the token claim.\nThen, sign this claim using the key which is the SECRET_KEY in the []byte form.\nIn the end, return the token as a response.\nVerify the Token #When the /me endpoint hit, it will execute the dashboard function.\nWe are going to send the token as Bearer Token. You can also send it as a key value pair in the request object.\nIn simple language, Bearer token is the same token with Bearer prefixed to it.\nBearer \u0026lt;Token\u0026gt; // dashboard User\u0026#39;s personalized dashboard func dashboard(w http.ResponseWriter, r *http.Request) { // get the bearer token from the reuest header bearerToken := r.Header.Get(\u0026#34;Authorization\u0026#34;) // validate token, it will return Token and error token, err := ValidateToken(bearerToken) if err != nil { // check if Error is Signature Invalid Error if err == jwt.ErrSignatureInvalid { // return the Unauthorized Status w.WriteHeader(http.StatusUnauthorized) return } // Return the Bad Request for any other error w.WriteHeader(http.StatusBadRequest) return } // Validate the token if it expired or not if !token.Valid { // return the Unauthoried Status for expired token w.WriteHeader(http.StatusUnauthorized) return } // Type cast the Claims to *Token type user := token.Claims.(*Token) // send the username Dashboard message json.NewEncoder(w).Encode(fmt.Sprintf(\u0026#34;%s Dashboard\u0026#34;, user.Username)) } // ValidateToken validates the token with the secret key and return the object func ValidateToken(bearerToken string) (*jwt.Token, error) { // format the token string tokenString := strings.Split(bearerToken, \u0026#34; \u0026#34;)[1] // Parse the token with tokenObj token, err := jwt.ParseWithClaims(tokenString, \u0026amp;Token{}, func(token *jwt.Token)(interface{}, error) { return key, nil }) // return token and err return token, err } Get the Bearer Token from the request header. The Bearer token\u0026rsquo;s key is Authorization.\nbearerToken := r.Header.Get(\u0026#34;Authorization\u0026#34;) Pass the bearerToken to the ValidateToken function. This function will validate the token if it is valid or not.\nUsing the ParseWithClaims method from the jwt-go package, it will validate the token and returns a *jwt.Token object and an error.\nTo get the user information from the *jwt.Token object, type cast it to (*Token).\nComplete Code #Create a new file main.go and paste the below code.\npackage main import ( \u0026#34;encoding/json\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;os\u0026#34; \u0026#34;strings\u0026#34; \u0026#34;time\u0026#34; jwt \u0026#34;github.com/dgrijalva/jwt-go\u0026#34; \u0026#34;github.com/gorilla/mux\u0026#34; \u0026#34;github.com/joho/godotenv\u0026#34; ) // Secret key to uniquely sign the token var key []byte // Credential User\u0026#39;s login information type Credential struct{ Username string `json:\u0026#34;username\u0026#34;` Password string `json:\u0026#34;password\u0026#34;` } // Token jwt Standard Claim Object type Token struct { Username string `json:\u0026#34;username\u0026#34;` jwt.StandardClaims } // Create a dummy local db instance as a key value pair var userdb = map[string]string{ \u0026#34;user1\u0026#34;: \u0026#34;password123\u0026#34;, } // assign the secret key to key variable on program\u0026#39;s first run func init() { // Load the .env file to access the environment variable err := godotenv.Load() if err != nil { log.Fatal(\u0026#34;Error loading .env file\u0026#34;) } // read the secret_key from the .env file key = []byte(os.Getenv(\u0026#34;SECRET_KEY\u0026#34;)) } func main() { r := mux.NewRouter() r.HandleFunc(\u0026#34;/login\u0026#34;, login).Methods(\u0026#34;POST\u0026#34;) r.HandleFunc(\u0026#34;/me\u0026#34;, dashboard).Methods(\u0026#34;GET\u0026#34;) fmt.Println(\u0026#34;Starting server on the port 8000...\u0026#34;) log.Fatal(http.ListenAndServe(\u0026#34;:8000\u0026#34;, r)) } // login user login function func login(w http.ResponseWriter, r *http.Request) { // create a Credentials object var creds Credential // decode json to struct err := json.NewDecoder(r.Body).Decode(\u0026amp;creds) if err != nil { w.WriteHeader(http.StatusBadRequest) return } // verify if user exist or not userPassword, ok := userdb[creds.Username] // if user exist, verify the password if !ok || userPassword != creds.Password { w.WriteHeader(http.StatusUnauthorized) return } // Create a token object var tokenObj = Token { Username: creds.Username, StandardClaims: jwt.StandardClaims{ // Enter expiration in milisecond ExpiresAt: time.Now().Add(10 * time.Minute).Unix(), }, } token := jwt.NewWithClaims(jwt.SigningMethodHS256, tokenObj ) tokenString, err := token.SignedString(key) if err != nil { log.Fatal(err) } json.NewEncoder(w).Encode(tokenString) } // dashboard User\u0026#39;s personalized dashboard func dashboard(w http.ResponseWriter, r *http.Request) { // get the bearer token from the reuest header bearerToken := r.Header.Get(\u0026#34;Authorization\u0026#34;) // validate token, it will return Token and error token, err := ValidateToken(bearerToken) if err != nil { // check if Error is Signature Invalid Error if err == jwt.ErrSignatureInvalid { // return the Unauthorized Status w.WriteHeader(http.StatusUnauthorized) return } // Return the Bad Request for any other error w.WriteHeader(http.StatusBadRequest) return } // Validate the token if it expired or not if !token.Valid { // return the Unauthoried Status for expired token w.WriteHeader(http.StatusUnauthorized) return } // Type cast the Claims to *Token type user := token.Claims.(*Token) // send the username Dashboard message json.NewEncoder(w).Encode(fmt.Sprintf(\u0026#34;%s Dashboard\u0026#34;, user.Username)) } // ValidateToken validates the token with the secret key and return the object func ValidateToken(bearerToken string) (*jwt.Token, error) { // format the token string tokenString := strings.Split(bearerToken, \u0026#34; \u0026#34;)[1] // Parse the token with tokenObj token, err := jwt.ParseWithClaims(tokenString, \u0026amp;Token{}, func(token *jwt.Token)(interface{}, error) { return key, nil }) // return token and err return token, err } Run the server #Open the terminal and first build the application.\ngo build It will generate a go-jwt-app.exe executable file.\n./go-jwt-app.exe Starting server on the port 8000... The server is started on the port 8000.\nTest the application #Open the Postman and create a new POST request.\nURL: http://localhost:8000/login Body: raw/JSON { \u0026#34;username\u0026#34;: \u0026#34;user1\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;password123\u0026#34; } Send the request. It will send a JWT token in the response.\nCopy the JWT Token.\nCreate a new GET request.\nURL: http://localhost:8000/me Auth: Bearer Token In the Token field, paste the JWT token from the last request and hit Send.\nIt will return \u0026quot;user1 Dashboard\u0026quot; as the response.\nConclusion #In this tutorial, we used the HS256 algorithm which accepts a text as a Secret Key. For more security, you can use other algorithms like ECDSA.\nFor ECDSA, you have to first create a private-public key pair.\nJWT is not the only method to secure the APIs. You should check out them too.\nThanks for reading.\nCover is designed in Canva\n","date":"July 30, 2020","permalink":"/posts/secure-your-api-using-jwt-in-golang/","section":"Posts","summary":"In this tutorial, we will learn how to secure the APIs using the JWT authentication in Golang.","title":"Secure Your Api Using Jwt in Golang"},{"content":"","date":null,"permalink":"/tags/email/","section":"Tags","summary":"","title":"email"},{"content":"This is the 2nd part of the How to send email in Nodejs series. In the last section, we created the function to send the email using node cli.\nIn this section, we will use the Expressjs and expose the functionality as an API. To test the api, we\u0026rsquo;re going to use 2 options Curl command and Postman.\nSeries: # How to Send Email in Nodejs - Part 1 How to Send Email in Nodejs with Expressjs - Part 2 Pre-requisite # Node.js (\u0026gt;v6.0.0 for nodemailer module) Code Editor (For Ex. VS Code, Atom) An account in Brevo (formerly Sendinblue) Getting Started #Let\u0026rsquo;s first install all the dependencies.\nexpress - To create routes body-parser - To access the parameters passed with API request cors - To handle the cross origin resource sharing dotenv - To access the .env file which we are going to use to save the credentials Open the terminal inside the project and run the below command.\nnpm install --save express body-parser cors dotenv Project Directory Structure #node-email |- routes |- mail-api.js |- src |- send-mail.js |- template |- mail.html |- .env |- index.js .env #In the last section, we entered the email and SMTP_KEY in the code, which is not recommended.\nWe should always use the environment variables in the code, to keep the secrets safe. Create a new file .env and paste your email and SMTP_KEY.\nUSER=EMAILADDRESS PASS=SMTP_KEY src #In the src folder, create a new file send-mail.js and paste the below code.\n\u0026#34;use strict\u0026#34;; require(\u0026#34;dotenv\u0026#34;).config(); const nodemailer = require(\u0026#34;nodemailer\u0026#34;); const path = require(\u0026#34;path\u0026#34;); /** * sendEmail * @param {Object} mailObj - Email information * @param {String} from - Email address of the sender * @param {Array} to - Array of receipents email address * @param {String} subject - Subject of the email * @param {String} text - Email body */ const sendEmail = async (mailObj) =\u0026gt; { const { from, to, subject, text } = mailObj; try { // Create a transporter let transporter = nodemailer.createTransport({ host: \u0026#34;smtp-relay.sendinblue.com\u0026#34;, port: 587, auth: { user: process.env.USER, pass: process.env.PASS, }, }); // send mail with defined transport object let info = await transporter.sendMail({ from: from, // sender address to: to, // list of receivers subject: subject, // Subject line text: text, // plain text body html: { path: path.resolve(__dirname, \u0026#34;../template/mail.html\u0026#34;), }, // html body }); console.log(`Message sent: ${info.messageId}`); return `Message sent: ${info.messageId}`; } catch (error) { console.error(error); throw new Error( `Something went wrong in the sendmail method. Error: ${error.message}` ); } }; module.exports = sendEmail; Let\u0026rsquo;s understand the code\nrequire(\u0026quot;dotenv\u0026quot;).config(); is used to load the .env file, so that using process.env.{KEY} we can access the environment variables defined in the .env file. The function takes an object with to, from, subject and text arguments. nodemailer.createTransport creating a transport object with all the required details of the message service provider and user access to that. transporter.sendMail: Enter all the details to mail. The text field send a plain text while the html field send the mail in the html format. routes #Open the routes folder and create a new file mail-api.js. In this file, we will create a send email route.\nThis endpoint then triggers the sendEmail function, defined in the src directory.\nCopy and paste the below code in the file.\nconst express = require(\u0026#34;express\u0026#34;); const router = express.Router(); const sendMailMethod = require(\u0026#34;../src/send-mail\u0026#34;); // Post request to send an email router.post(\u0026#34;/sendmail\u0026#34;, async (req, res) =\u0026gt; { try { const result = await sendMailMethod(req.body); // send the response res.json({ status: true, payload: result, }); } catch (error) { console.error(error.message); res.json({ status: false, payload: \u0026#34;Something went wrong in Sendmail Route.\u0026#34;, }); } }); module.exports = router; Instead of taking out the variables from the req.body, we directly send this to the function as it is accepting an object.\nThis approach is optional, if the application requires the input validation, then validate it at route end, instead of at method end. As it is for education purpose not for production.\ntemplate #In the html field of sendMail method, it can read the pure html code. But this is not recommended.\nInstead you can create a mail.html template and give its path to it.\nCreate a new file mail.html and paste the below code in it.\n\u0026lt;div style=\u0026#34;text-align: center;\u0026#34;\u0026gt; \u0026lt;h1 style=\u0026#34;color: #3584c8;\u0026#34;\u0026gt;Nodemailer Example\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt; This is an example html template to demonstrate the sending email using html. \u0026lt;br /\u0026gt; 🤗 🤗 🤗 🤗 🤗 🤗 \u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; You can use a dynamic html template, in which you pass the arguments. But that is out of the scope for this tutorial.\nindex.js #Open the index.js and paste the below code. This index.js is the entry point for this application. It is importing all the application route and creating a express server to host the application on 4444 port.\n\u0026#34;use strict\u0026#34;; const express = require(\u0026#34;express\u0026#34;); const bodyParser = require(\u0026#34;body-parser\u0026#34;); const cors = require(\u0026#34;cors\u0026#34;); const app = express(); const mailAPI = require(\u0026#34;./routes/mail-api.js\u0026#34;); // Express body parser app.use(cors()); app.use(bodyParser.json()); app.use( bodyParser.urlencoded({ limit: \u0026#34;50mb\u0026#34;, extended: false, parameterLimit: 50000, }) ); // use the routes specified in route folder app.use(\u0026#34;/api/v1\u0026#34;, mailAPI); const port = process.env.PORT || 4444; //listen to the server app.listen(port, function () { console.log(`listening to the port ${port} .....`); }); Run Time #Now, the fun part. Let\u0026rsquo;s send some emails.\nOpen the terminal inside the project directory and run the below command.\nnode index.js This will start the server at 4444 if no PORT environment variable defined.\nOpen the Postman and create a POST request to localhost:4444/api/v1/sendmail.\nIn the Body tab, select the JSON option. Modify the body accordingly.\n{ \u0026#34;from\u0026#34;: \u0026#34;hello@schadokar.dev\u0026#34;, \u0026#34;to\u0026#34;: [ \u0026#34;shubham@schadokar.dev\u0026#34; ], \u0026#34;subject\u0026#34;: \u0026#34;Mail from Nodemailer\u0026#34;, \u0026#34;message\u0026#34;: \u0026#34;Sending an email using nodemailer package.\u0026#34; } Hit Send.\nCheck Email #Open you email and check the inbox. If you could not find it in inbox try to check in promotion.\nText email #If you haven\u0026rsquo;t used the html field in the sendMail then your mail will look like this.\nHTML email #When you are using html field then it ignores the text field and only send the html message.\nConclusion #We have finished the api part of this application and with this our backend is completed.\nNow, you can use any frontend framework to utilize this API.\nYou can find the complete code on the GitHub.\nThanks for reading.\nCover is designed in Canva\n","date":"July 26, 2020","permalink":"/posts/how-to-send-email-in-nodejs-with-expressjs/","section":"Posts","summary":"This is the 2nd part of the How to send email in Nodejs series.","title":"How to Send Email in Nodejs with Expressjs"},{"content":"","date":null,"permalink":"/tags/tutorial/","section":"Tags","summary":"","title":"tutorial"},{"content":"","date":null,"permalink":"/categories/tutorial/","section":"Categories","summary":"","title":"Tutorial"},{"content":"This is a series of articles on how to send an email in nodejs.\nIn the first article, we will send an email using the node command. Later, we will create a APIs and a frontend.\nSending emails in nodejs have only 2 requirements:\nMail service provider (For ex. Gmail, Sendinblue, Mailchimp) Middleware to connect with mail service (For ex. nodemailer) Series: # How to Send Email in Nodejs - Part 1 How to Send Email in Nodejs with Expressjs - Part 2 Prerequisites # Node.js (\u0026gt;v6.0.0 for nodemailer module) Code Editor (For Ex. VS Code, Atom) An account in Brevo (formerly Sendinblue) Getting Started #For this series, we are going to use nodemailer package. It is an open source project.\nNodemailer Features # A single module with Zero dependencies Support HTML Content Add attachments to messages Supports SMTP as default transport method. Other supported transport methods are SES, Sendmail, Stream. OAuth2 authentication For the mailing service, we are going to use Sendinblue. This mailing service offers many different solutions other than emails, for ex. SMS.\nIt provide 300 mails/day for a free account and paid account is also very cheap and offer more features compared to many other available mailing service provider.\nCreate a new Project #Create a new directory node-email. Open the terminal or cmd inside the directory.\nInitiate the nodejs project using the npm init -y command. -y flag is optional, by passing this flag it uses the default arguments.\nInstall Nodejs Dependencies #Install nodemailer package.\nnpm install --save nodemailer Create a new SMTP Key in Brevo (formerly Sendinblue) #This key will be used for authentication and sending the email via your Brevo (formerly Sendinblue).\nSign in to your Brevo (formerly Sendinblue) and click on SMTP \u0026amp; API from the top-right menu.\nGo to SMTP tab and click on CREATE A NEW SMTP KEY. Copy the key and paste it somewhere safe.\n⚠️ Note: If you lose this key, then you can\u0026rsquo;t retrieve it. Then you have to create a new one and replace it accordingly.\nSend Email #Create a index.js file and paste the below code.\n\u0026#34;use strict\u0026#34;; const nodemailer = require(\u0026#34;nodemailer\u0026#34;); /** * sendEmail * @param {Object} mailObj - Email meta data and body * @param {String} from - Email address of the sender * @param {Array} recipients - Array of recipients email address * @param {String} subject - Subject of the email * @param {String} message - message */ const sendEmail = async (mailObj) =\u0026gt; { const { from, recipients, subject, message } = mailObj; try { // Create a transporter let transporter = nodemailer.createTransport({ host: \u0026#34;smtp-relay.sendinblue.com\u0026#34;, port: 587, auth: { user: \u0026#34;hello@schadokar.dev\u0026#34;, pass: \u0026#34;SMTP-KEY\u0026#34;, }, }); // send mail with defined transport object let mailStatus = await transporter.sendMail({ from: from, // sender address to: recipients, // list of recipients subject: subject, // Subject line text: message, // plain text }); console.log(`Message sent: ${mailStatus.messageId}`); return `Message sent: ${mailStatus.messageId}`; } catch (error) { console.error(error); throw new Error( `Something went wrong in the sendmail method. Error: ${error.message}` ); } }; const mailObj = { from: \u0026#34;hello@schadokar.dev\u0026#34;, recipients: [\u0026#34;me@schadokar.dev\u0026#34;], subject: \u0026#34;Sending email by nodejs\u0026#34;, message: \u0026#34;Hello World;\u0026#34;, }; sendEmail(mailObj).then((res) =\u0026gt; { console.log(res); }); In the auth object, user will be your email address of Brevo (formerly Sendinblue) and pass will be your SMTP KEY.\nIn the mailObj, from will be your email address of Brevo (formerly Sendinblue), recipients is an array of email addresses, subject is subject of email and message is plain text message.\nOpen the terminal and run the file.\nnode index.js On successful run, output will be\nMessage sent: \u0026lt;72ff9668-8200-831b-e585-afbeaeeea09d@schadokar.dev\u0026gt; Message sent: \u0026lt;72ff9668-8200-831b-e585-afbeaeeea09d@schadokar.dev\u0026gt; Now, go and check your mailbox. You have received a mail. If you could not find the mail, check in the promotion.\nConclusion #In this tutorial, we created a basic sendEmail function to send the email using the nodemailer package. In the next section, we are going to create the server and APIs and in the last section we will send the email using the frontend.\nCover is designed in Canva\n","date":"July 19, 2020","permalink":"/posts/how-to-send-email-in-nodejs/","section":"Posts","summary":"This is a series of articles on how to send an email in nodejs.","title":"How to Send Email in Nodejs"},{"content":"","date":null,"permalink":"/tags/nodejs/","section":"Tags","summary":"","title":"nodejs"},{"content":"","date":null,"permalink":"/tags/sendemail/","section":"Tags","summary":"","title":"sendemail"},{"content":"In this post of to-the-point series, we will convert a hex string to a byte array and vice-versa. For this, we\u0026rsquo;re going to use the encoding/hex package provided by the golang. Package hex implements hexadecimal encoding and decoding.\nbyte array to hex string #To convert a byte array to hex string, we will encode the byte array to the hexadecimal string.\nSyntax #func EncodeToString(src []byte) string First we will convert a string to a byte array.\npackage main import ( \u0026#34;encoding/hex\u0026#34; \u0026#34;fmt\u0026#34; ) func main() { byteArray := []byte(\u0026#34;Learn Go!\u0026#34;) fmt.Println(\u0026#34;byteArray: \u0026#34;, byteArray) encodedString := hex.EncodeToString(byteArray) fmt.Println(\u0026#34;Encoded Hex String: \u0026#34;, encodedString) } Output\nbyteArray: [76 101 97 114 110 32 71 111 33] Encoded Hex String: 4c6561726e20476f21 Try it\nhex string to byte array #To convert hex string to byte array, we will decode the encoded hex string.\nSyntax #func DecodeString(s string) ([]byte, error) We are going to use the same hex string from above.\npackage main import ( \u0026#34;encoding/hex\u0026#34; \u0026#34;fmt\u0026#34; ) func main() { hexString := \u0026#34;4c6561726e20476f21\u0026#34; fmt.Println(\u0026#34;Hex String: \u0026#34;, hexString) decodedByteArray, err := hex.DecodeString(hexString) if err != nil { fmt.Println(\u0026#34;Unable to convert hex to byte. \u0026#34;, err) } fmt.Printf(\u0026#34;Decoded Byte Array: %v \\nDecoded String: %s\u0026#34;, decodedByteArray, decodedByteArray) } Try it\nOutput\nHex String: 4c6561726e20476f21 Decoded Byte Array: [76 101 97 114 110 32 71 111 33] Decoded String: Learn Go! ","date":"July 18, 2020","permalink":"/to-the-point/convert-byte-to-hex-and-hex-to-byte-in-golang/","section":"To-the-Points","summary":"In this post of to-the-point series, we will convert a hex string to a byte array and vice-versa.","title":"Convert Byte to Hex and Hex to Byte in Golang"},{"content":"","date":null,"permalink":"/tags/to-the-point/","section":"Tags","summary":"","title":"to-the-point"},{"content":"This is a series of tutorials: sending email in golang. We\u0026rsquo;ll first start with the basic sending an email using the go command.\nIn the upcoming tutorials, we will create an API and a frontend using which we will send emails.\nIn this tutorial, we will send an email using the main.go file.\nPre-requisites # go v1.11 or greater - I am using go1.14.3 Code Editor (VSCode, Atom) - I am using VS Code Brevo (formerly Sendinblue) account - link Getting Started #Create a new directory go-sendinblue.\nOpen the terminal inside the directory and run the below command.\ngo mod init go-sendinblue This command will initiate a module go.mod.\nA module is a collection of dependency modules used in the project. This will list all the dependencies with their version in the go.mod file.\nAdd the Dependency #In this project, we are going to use the environment variables from the .env file. To access the .env file and use it we have to add a dependency godotenv.\ngo get github.com/joho/godotenv This package is simple and clean.\nLearn more about how to use environment variables in the golang.\nCreate a new SMTP Key #Sign in to your Brevo (formerly Sendinblue) account and click on SMTP \u0026amp; API from the top-right menu.\nGo to SMTP tab and click on CREATE A NEW SMTP KEY.\nCopy the key and paste it somewhere safe.\n⚠️ Note: If you lose this key, then you can\u0026rsquo;t retrieve it. Then you have to create a new one and replace it accordingly.\nEnvironment Variable #Create a new .env file inside the go-sendinblue project.\nOpen the file and enter the following keys and values.\nPASSWORD=Enter your Sendinblue SMTP Key SMTP_HOST=smtp-relay.sendinblue.com SMTP_PORT=587 Verify the SMTP_HOST and SMTP_PORT from the SMTP \u0026amp; API section of your account.\n⚠️ Caution: If you\u0026rsquo;re using git then don\u0026rsquo;t forget to add .env in the .gitignore file. This will prevent your secrets to access by anyone.\nCoding Time 👨‍💻 #Create a new main.go inside the go-sendinblue project.\nOpen the main.go file and paste the below code. We are going to use smtp package provided by golang.\nPackage smtp implements the Simple Mail Transfer Protocol as defined in RFC 5321.\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;net/smtp\u0026#34; \u0026#34;os\u0026#34; // Import godotenv \u0026#34;github.com/joho/godotenv\u0026#34; ) func main() { // From address from := \u0026#34;hello@schadokar.dev\u0026#34; // Array of recipients address to := []string{\u0026#34;shubham@schadokar.dev\u0026#34;} // Create a message and convert it into bytes msg := []byte(\u0026#34;To: shubham@schadokar.dev\\r\\n\u0026#34; + \u0026#34;From: hello@schadokar.dev\\r\\n\u0026#34; + \u0026#34;Subject: Hello Gophers!\\r\\n\u0026#34; + \u0026#34;\\r\\n\u0026#34; + \u0026#34;This is the email is sent using golang and Brevo (formerly Sendinblue).\\r\\n\u0026#34;) // Call the sendEmail function status := sendEmail(from, to, msg) // check if email sent successfully or not if status { fmt.Printf(\u0026#34;Email sent successfully.\u0026#34;) } else { fmt.Printf(\u0026#34;Email sent failed.\u0026#34;) } } // send mail function func sendEmail(from string, to []string, msg []byte) bool { // Load .env file to use the environment variable err := godotenv.Load(\u0026#34;.env\u0026#34;) if err != nil { log.Fatalf(\u0026#34;Error loading .env file\u0026#34;) } // Set up authentication information. auth := smtp.PlainAuth(\u0026#34;\u0026#34;, from, os.Getenv(\u0026#34;PASSWORD\u0026#34;), os.Getenv(\u0026#34;SMTP_HOST\u0026#34;)) // format smtp address smtpAddress := fmt.Sprintf(\u0026#34;%s:%v\u0026#34;, os.Getenv(\u0026#34;SMTP_HOST\u0026#34;), os.Getenv(\u0026#34;SMTP_PORT\u0026#34;)) // Connect to the server, authenticate, set the sender and recipient, // and send the email all in one step. err = smtp.SendMail(smtpAddress, auth, from, to, msg) if err != nil { log.Fatal(err) return false } // return true on success return true } Let\u0026rsquo;s understand the code piece by piece.\nIn the main function we\u0026rsquo;re first declaring the from, to, and msg.\nfrom is the address from which you created the Brevo (formerly Sendinblue). to is an array of string.\nmsg is an array of bytes.\n⚠️ You must define the From field in the msg. It is not mentioned in the smtp package documentation. Maybe it is only required for Brevo (formerly Sendinblue). I have not tested with other mail service providers.\nIn the sendEmail function, it is taking from, to, and msg as arguments and returning a bool status.\nIn the import, we have imported the github.com/joho/godotenv package to load the .env file. To load the .env file, use Load method of godoenv. From the .env file, we will load PASSWORD, SMTP_HOST and SMTP_PORT.\nThe smtp package has 2 methods to authenticate the mail server. Read more\nWe\u0026rsquo;re going to use the PlainAuth method.\nSyntax #func PlainAuth(identity, username, password, host string) Auth PlainAuth returns an Auth that implements the PLAIN authentication mechanism as defined in RFC 4616. The returned Auth uses the given username and password to authenticate to host and act as identity. Usually, identity should be the empty string, to act as username.\nPlainAuth will only send the credentials if the connection is using TLS or is connected to localhost. Otherwise, authentication will fail with an error, without sending the credentials.\nNow, as the .env is loaded by the godotenv package. We can use os package to read the environment variables.\nFormat an SMTP Address.\nsmtp-relay.sendinblue.com:587 Use os package to read PASSWORD, SMTP_HOST and SMTP_PORT.\nUsing the SendMail method of smtp package, it can connect to the server, authenticate and send the email the message to all the recipients by the sender.\nSend the email #Open the project in the terminal and run the below command.\ngo run main.go Check your mailbox. You have received a mail. If you could not find the mail check in the promotion.\nThe smtp package does not provide enough information of delivery of the mail. It only confirms if mail sent to server or not.\nFrom server side, there can be many reasons if it is delivered or not. To check if sent successfully or not.\nOpen the Brevo (formerly Sendinblue) account and click on the Transactional tab.\nIn this tab, you can check the status of the mail. The common reason can be an incorrect mail address. For this it raise a Hard bounce event.\nConclusion #Hope, you find this tutorial helpful. The complete code is available on my GitHub repository.\nIn the upcoming tutorials, we are going to create API and a frontend.\n","date":"June 11, 2020","permalink":"/posts/how-to-send-email-in-golang/","section":"Posts","summary":"This is a series of tutorials: sending email in golang.","title":"How to Send Email in Golang"},{"content":"","date":null,"permalink":"/tags/sendinblue/","section":"Tags","summary":"","title":"sendinblue"},{"content":"In this tutorial, we will learn how to read and write files in the file system using the io/ioutil package.\nWrite a file using WriteFile #The WriteFile function takes 3 arguments, filename, data in a byte array, and filemode.\nfunc WriteFile(filename string, data []byte, perm os.FileMode) error A FileMode represents a file\u0026rsquo;s mode and permission bits. Learn more\npackage main import ( \u0026#34;io/ioutil\u0026#34; \u0026#34;log\u0026#34; ) func main() { // create a byte array of a string data := []byte(\u0026#34;Hello Gopher!\u0026#34;) // write data to a hello file, with 0777 file permission err := ioutil.WriteFile(\u0026#34;hello.txt\u0026#34;, data, 0777) if err != nil { log.Fatalf(\u0026#34;%v\u0026#34;, err) } } This will create a new file hello.txt in the current directory.\nFile mode #Most file systems have methods to assign permissions or access rights to specific users and groups of users. These permissions control the ability of the users to view, change, navigate, and execute the contents of the file system. \u0026ndash; wikipedia\nA few examples of filemode number notation.\n0000 no permissions 0700 read, write, \u0026amp; execute only for owner 0770 read, write, \u0026amp; execute for owner and group 0777 read, write, \u0026amp; execute for owner, group and others 0111 execute 0222 write 0333 write \u0026amp; execute 0444 read 0555 read \u0026amp; execute 0666 read \u0026amp; write 0740 owner can read, write, \u0026amp; execute; group can only read; others have no permissions Read a file using ReadFile #The ReadFile function reads the file by its filename and returns the file data in array of byte.\nfunc ReadFile(filename string) ([]byte, error) We will read the above created hello.txt file. Please create a file if it is not created.\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;io/ioutil\u0026#34; \u0026#34;log\u0026#34; ) func main() { // read the hello.txt content, err := ioutil.ReadFile(\u0026#34;hello.txt\u0026#34;) if err != nil { log.Fatalf(\u0026#34;error while reading %v\u0026#34;, err) } // convert the byte into string fmt.Println(string(content)) } Output\nHello Gopher! Write to an existing file #1. using ioutil #First using ReadFile, we will read the content and then we will append the new content.\npackage main import ( \u0026#34;io/ioutil\u0026#34; \u0026#34;log\u0026#34; ) func main() { // Read the content content, err := ioutil.ReadFile(\u0026#34;hello.txt\u0026#34;) if err != nil { log.Fatalf(\u0026#34;error while reading the file. %v\u0026#34;, err) } // new content newText := []byte(\u0026#34;\\nAppended text.\u0026#34;) // append the content content = append(content, newText...) // overwrite the content of hello.txt err = ioutil.WriteFile(\u0026#34;hello.txt\u0026#34;, content, 0777) if err != nil { log.Fatalf(\u0026#34;error while writing the file. %v\u0026#34;, err) } } The 3 dots after newText... is a variadic argument. In simple terms it will extract all the array elements. Learn more\nFor Example:\nif a = [1,2,3,4] func (a...) =\u0026gt; func (1, 2, 3, 4) 2. using os package #Using OpenFile in the os package we can open the file and append the data in it.\nPackage os provides a platform-independent interface to operating system functionality.\nfunc OpenFile(name string, flag int, perm FileMode) (*File, error) The flag parameter defines the operation on the file. The available flags are:\nO_RDONLY int = syscall.O_RDONLY // open the file read-only. O_WRONLY int = syscall.O_WRONLY // open the file write-only. O_RDWR int = syscall.O_RDWR // open the file read-write. // The remaining values may be or\u0026#39;ed in to control behavior. O_APPEND int = syscall.O_APPEND // append data to the file when writing. O_CREATE int = syscall.O_CREAT // create a new file if none exists. O_EXCL int = syscall.O_EXCL // used with O_CREATE, file must not exist. O_SYNC int = syscall.O_SYNC // open for synchronous I/O. O_TRUNC int = syscall.O_TRUNC // truncate regular writable file when opened. Example\npackage main import ( \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; ) func main() { // If the file doesn\u0026#39;t exist, create it, or append to the file file, err := os.OpenFile(\u0026#34;hello.txt\u0026#34;, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0777) if err != nil { log.Fatalf(\u0026#34;error while opening the file. %v\u0026#34;, err) } // close the file once program execution complete defer file.Close() if _, err := file.Write([]byte(\u0026#34;\\nappended data\u0026#34;)); err != nil { log.Fatalf(\u0026#34;error while writing the file. %v\u0026#34;, err) } } Read and Write a JSON file #Reading and writing the JSON file requires to unmarshal and marshal the data respectively.\nLearn more about How to use JSON in Golang\nWe are going to create a library object and a book object. The library stores the array of books.\ntype book struct { Name string Author string } type library struct { Books []book } Create books and library\n// create some books books := []book{ {Name: \u0026#34;An Introduction to programming in Go\u0026#34;, Author: \u0026#34;Caleb Doxsey\u0026#34;}, {Name: \u0026#34;Go in Action\u0026#34;, Author: \u0026#34;William Kennedy\u0026#34;}, {Name: \u0026#34;The way to Go\u0026#34;, Author: \u0026#34;IVO BALBAERT\u0026#34;}, } // create the library with books lib := library{Books: books} Write JSON #The library is in golang struct format. To convert it JSON we need to marshal it.\n// marshal to json or convert to json libJSON, _ := json.Marshal(lib) Save it in library.json\n// write to library.json err := ioutil.WriteFile(\u0026#34;library.json\u0026#34;, libJSON, 0777) if err != nil { log.Fatalf(\u0026#34;Error while writing a file %v\u0026#34;, err) } Read JSON #Read the library.json.\n// Read the file content, err := ioutil.ReadFile(\u0026#34;library.json\u0026#34;) if err != nil { log.Fatalf(\u0026#34;Error while reading a file %v\u0026#34;, err) } The data is in byte. Unmarshal it to access the data.\n// create a new library var readLib library // unmarshal the json to library err = json.Unmarshal(content, \u0026amp;readLib) if err != nil { log.Fatalf(\u0026#34;Error while unmarshal the content %v\u0026#34;, err) } // print all the books for i, book := range readLib.Books { fmt.Printf(\u0026#34;%v| Name: %-40s | Author: %s\\n\u0026#34;, i, book.Name, book.Author) } Output\n0| Name: An Introduction to programming in Go | Author: Caleb Doxsey 1| Name: Go in Action | Author: William Kennedy 2| Name: The way to Go | Author: IVO BALBAERT The output is formatted because we used a little string formatting.\nIn the Printf, we have used %-40s. 40 is the width. - align the data to left. Learn more about string formatting.\nWidth is measured in units of Unicode code points, that is, runes.\nFor most values, width is the minimum number of runes to output, padding the formatted form with spaces if necessary.\nThe complete code will look like this\npackage main import ( \u0026#34;encoding/json\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;io/ioutil\u0026#34; \u0026#34;log\u0026#34; ) type book struct { Name string Author string } type library struct { Books []book } func main() { // create some books books := []book{ {Name: \u0026#34;An Introduction to programming in Go\u0026#34;, Author: \u0026#34;Caleb Doxsey\u0026#34;}, {Name: \u0026#34;Go in Action\u0026#34;, Author: \u0026#34;William Kennedy\u0026#34;}, {Name: \u0026#34;The way to Go\u0026#34;, Author: \u0026#34;IVO BALBAERT\u0026#34;}, } // create the library with books lib := library{Books: books} // marshal to json or convert to json libJSON, _ := json.Marshal(lib) // write to library.json err := ioutil.WriteFile(\u0026#34;library.json\u0026#34;, libJSON, 0777) if err != nil { log.Fatalf(\u0026#34;Error while writing a file %v\u0026#34;, err) } // Read the file content, err := ioutil.ReadFile(\u0026#34;library.json\u0026#34;) if err != nil { log.Fatalf(\u0026#34;Error while reading a file %v\u0026#34;, err) } // create a new library var readLib library // unmarshal the json to library err = json.Unmarshal(content, \u0026amp;readLib) if err != nil { log.Fatalf(\u0026#34;Error while unmarshal the content %v\u0026#34;, err) } // print all the books for i, book := range readLib.Books { fmt.Printf(\u0026#34;%v| Name: %-40s | Author: %s\\n\u0026#34;, i, book.Name, book.Author) } } Update the existing JSON file #We will use ioutil for this. First, we will read library.json and then we add a new book in it.\npackage main import ( \u0026#34;encoding/json\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;io/ioutil\u0026#34; \u0026#34;log\u0026#34; ) type book struct { Name string Author string } type library struct { Books []book } func main() { // Read the file content, err := ioutil.ReadFile(\u0026#34;library.json\u0026#34;) if err != nil { log.Fatalf(\u0026#34;Error while reading a file %v\u0026#34;, err) } // create a new library var readLib library // unmarshal the json to library err = json.Unmarshal(content, \u0026amp;readLib) if err != nil { log.Fatalf(\u0026#34;Error while unmarshal the content %v\u0026#34;, err) } // before update fmt.Println(\u0026#34;Before Update\u0026#34;) // print all the books for i, book := range readLib.Books { fmt.Printf(\u0026#34;%v| Name: %-40s | Author: %s\\n\u0026#34;, i, book.Name, book.Author) } // Update newBook := book{ Name: \u0026#34;Go Web Programming\u0026#34;, Author: \u0026#34;Sau Sheong Chang\u0026#34;, } // append the new book readLib.Books = append(readLib.Books, newBook) // write the book // marshal to json or convert to json libJSON, err := json.Marshal(readLib) if err != nil { log.Fatalf(\u0026#34;Error while marshal. %v\u0026#34;, err) } // write to library.json err = ioutil.WriteFile(\u0026#34;library.json\u0026#34;, libJSON, 0777) if err != nil { log.Fatalf(\u0026#34;Error while writing a file %v\u0026#34;, err) } // After Update fmt.Println(\u0026#34;After update\u0026#34;) // Read the file content, err = ioutil.ReadFile(\u0026#34;library.json\u0026#34;) if err != nil { log.Fatalf(\u0026#34;Error while reading a file %v\u0026#34;, err) } // unmarshal the json to library err = json.Unmarshal(content, \u0026amp;readLib) if err != nil { log.Fatalf(\u0026#34;Error while unmarshal the content %v\u0026#34;, err) } // print all the books for i, book := range readLib.Books { fmt.Printf(\u0026#34;%v| Name: %-40s | Author: %s\\n\u0026#34;, i, book.Name, book.Author) } } Output\nBefore Update 0| Name: An Introduction to programming in Go | Author: Caleb Doxsey 1| Name: Go in Action | Author: William Kennedy 2| Name: The way to Go | Author: IVO BALBAERT After update 0| Name: An Introduction to programming in Go | Author: Caleb Doxsey 1| Name: Go in Action | Author: William Kennedy 2| Name: The way to Go | Author: IVO BALBAERT 3| Name: Go Web Programming | Author: Sau Sheong Chang References # How to use JSON in Golang? Golang documentation ","date":"March 24, 2020","permalink":"/to-the-point/how-to-read-and-write-a-file-in-golang/","section":"To-the-Points","summary":"In this tutorial, we will learn how to read and write files in the file system using the io/ioutil package.","title":"How to Read and Write a File in Golang?"},{"content":"","date":null,"permalink":"/tags/json/","section":"Tags","summary":"","title":"json"},{"content":"When you start a project which interacts with the outer world, it requires data exchange. To make a project successful this interaction must be simple and efficient.\nWhat is Data Exchange? # Data exchange is the process of taking data structured under a source schema and transforming it into data structured under a target schema, so that the target data is an accurate representation of the source data. - Wikipedia\nIn simple terms, convert the data in the format which the receiver understands.\nThere are many data exchange formats like XML, JSON, HTML, CSV etc. Among all, JSON has become ubiquitous for web applications.\nWhat is JSON? #JSON (JavaScript Object Notation) is a lightweight format that is used for data interchanging. It is based on a subset of Javascript language. An object is an unordered set of name/value pairs.\nAn Example of JSON\n{ \u0026#34;title\u0026#34;: \u0026#34;How to use JSON in golang?\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Tutorial\u0026#34;, \u0026#34;publisher\u0026#34;: \u0026#34;codesource.io\u0026#34;, \u0026#34;tags\u0026#34;: [\u0026#34;golang\u0026#34;, \u0026#34;json\u0026#34;], \u0026#34;published\u0026#34;: true } Now, we know what is JSON. It is time to use it with golang. In this tutorial, we will explore different golang types like string, int, struct, array, slice, maps.\nParse JSON in Golang ⚙️ #JSON is JavaScript Object Notation and golang can\u0026rsquo;t use it in its original format. For this, golang has provided an encoding/json package in the standard library.\nIn golang, we use struct to represent json.\nFor example: In golang\ntype Employer struct { Name string Employee []int } In JSON\n{ \u0026#34;name\u0026#34;: \u0026#34;string\u0026#34;, \u0026#34;employee\u0026#34;: [] } We will use encode/json package to convert json into struct and struct into json. For this we will use 2 functions:\nMarshal (Encode) : Convert golang struct into json format. Unmarshal (Decode): Convert json into golang struct It is more like mapping the parameters than conversion. The default Go types for decoding and encoding JSON are\nbool for JSON boolean string for JSON string int/float64 for JSON number nil for JSON null Encode (Marshal) 👨‍💻 #To encode JSON data we use the Marshal function.\nfunc Marshal(v interface{}) ([]byte, error) Marshal function accepts an empty interface and returns an array of byte and error message.\npackage main import ( \u0026#34;encoding/json\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; ) func main() { type Person struct { Name string Age int64 Location string } person := Person{ \u0026#34;Jon\u0026#34;, 27, \u0026#34;London\u0026#34;, } // encode into JSON b, err := json.Marshal(person) if err != nil { log.Fatalf(\u0026#34;Unable to encode\u0026#34;) } // Marshal returns []byte fmt.Println(string(b)) } Try It\nOutput\n{ \u0026#34;Name\u0026#34;: \u0026#34;Jon\u0026#34;, \u0026#34;Age\u0026#34;: 27, \u0026#34;Location\u0026#34;: \u0026#34;London\u0026#34; } We are encoding Person struct in JSON format. First, create a new object of Person as person. Then, encode the person in JSON using json.Marshal. If everything goes well, then the err will be nil and b is the representation of person in []byte format.\nOnly data structures that can be represented as valid JSON will be encoded:\nJSON objects only support strings as keys; to encode a Go map type it must be of the form map[string]T (where T is any Go type supported by the json package). Only the exported fields (those that begin with an uppercase letter) of the struct can be encoded in JSON. Cyclic data structures are not supported; they will cause Marshal to go into an infinite loop. Pointers will be encoded as the values they point to (or \u0026rsquo;null\u0026rsquo; if the pointer is nil). In golang Uppercase represent that a field is exported or public.\nTake a look at the Person struct,\ntype Person struct { Name string Age int64 Location string } Change the Location field to lowercase location.\ntype Person struct { Name string Age int64 location string } Try it\nOutput\n{ \u0026#34;Name\u0026#34;: \u0026#34;Jon\u0026#34;, \u0026#34;Age\u0026#34;: 27 } To map the struct field to the json tag. #For example, you have struct field as Name but you want to map it as firstName in json. To do this, you can tag the struct field.\nSyntax\nFieldName type `json:\u0026#34;tagname\u0026#34;` ⚠️ Don\u0026rsquo;t give any space between json:\u0026quot;tagname\u0026quot;, else it will throw an error. struct field tag json: \u0026quot;firstName\u0026quot; not compatible with reflect.StructTag.Get: bad syntax for struct tag value\nTag the Name field as firstName.\ntype Person struct { Name string `json:\u0026#34;firstName\u0026#34;` Age int64 Location string } Try it\nOutput\n{ \u0026#34;firstName\u0026#34;: \u0026#34;Jon\u0026#34;, \u0026#34;Age\u0026#34;: 27, \u0026#34;Location\u0026#34;: \u0026#34;London\u0026#34; } Omitempty #We have a special json tag as omitempty. If a field is set as omitempty then it will not encode that field to json if it is empty.\nFor example, set Location field as omitempty.\ntype Person struct { Name string `json:\u0026#34;firstName\u0026#34;` Age int64 Location string `json:\u0026#34;location, omitempty\u0026#34;` } person := Person{ Name: \u0026#34;Jon\u0026#34;, Age: 27, } Try it\nOutput\n{\u0026#34;firstName\u0026#34;:\u0026#34;Jon\u0026#34;,\u0026#34;Age\u0026#34;:27} Decode (Unmarshal) 👨‍💻 #To decode JSON data we use the Unmarshal function.\nfunc Unmarshal(data []byte, v interface{}) error Unmarshal accepts an array of byte and an interface and returns the error message. This interface is the struct to which the JSON decode.\npackage main import ( \u0026#34;encoding/json\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; ) func main() { type Person struct { Name string Age int64 Location string } j := []byte(`{\u0026#34;name\u0026#34;:\u0026#34;Jon\u0026#34;,\u0026#34;age\u0026#34;:27,\u0026#34;location\u0026#34;:\u0026#34;London\u0026#34;}`) var p Person err := json.Unmarshal(j, \u0026amp;p) if err != nil { log.Fatalf(\u0026#34;Unable to decode the json\u0026#34;) } fmt.Println(p) } Try it\nOutput\n{Jon 27 London} To store the decoded data in the struct, Unmarshal will look the json case-insensitive keys in the exported struct fields. As in the above case, name is in lowercase and is mapped to the exported Name field.\nSimilar, to encoding you can add json tag to the struct field. For example:\nTag the Name field with json:\u0026quot;firstName\u0026quot;. Now, it will map firstName to the Name.\ntype Person struct { Name string `json:\u0026#34;firstName\u0026#34;` Age int64 Location string } Try it\nDecoding the arbitrary JSON 👨‍💻 #In the above examples, we knew the JSON structure and we mapped it to the struct.\nWhat if you don\u0026rsquo;t know the JSON structure? 🤔\nIn the json all the keys must be string. It means we can use the map type for arbitrary data.\nThe encoding/json package uses\nmap[string]interface{} to store the arbitrary JSON objects []interface{} to store the arbitrary JSON arrays. In map[string]interface{} the keys are string and values are interface{}. It is an empty interface. The interface{} (empty interface) type describes an interface with zero methods. In short, it can accept all the types.\nThe default Go types are:\nbool for JSON booleans, float64 for JSON numbers, string for JSON strings, and nil for JSON null. Consider the JSON object as\n{ \u0026#34;name\u0026#34;: \u0026#34;Jon\u0026#34;, \u0026#34;location\u0026#34;: { \u0026#34;country\u0026#34;: \u0026#34;England\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;London\u0026#34; }, \u0026#34;hobbies\u0026#34;: [\u0026#34;photography\u0026#34;, \u0026#34;writing\u0026#34;] } The Unmarshal function will parse it into a map whose keys are string and values are empty interface.\nmap[string]interface{} { \u0026#34;Name\u0026#34;: \u0026#34;Jon\u0026#34;, \u0026#34;Location\u0026#34;: map[string]interface{} { \u0026#34;Country\u0026#34;: \u0026#34;England\u0026#34;, \u0026#34;City\u0026#34;: \u0026#34;London\u0026#34;, }, \u0026#34;Hobbies\u0026#34;: []interface{} { \u0026#34;photography\u0026#34;, \u0026#34;writing\u0026#34;, }, } All the values are of type interface{}. To access the underlying type of interface, we have to use type assertion.\nFor example:\nvar name interface{} name = \u0026#34;Jon\u0026#34; result := name.(string) fmt.PrintF(\u0026#34;Type is %T, value is %s\u0026#34;, result, result\u0026#34;) Try it\npackage main import ( \u0026#34;encoding/json\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; ) func main() { jsonObj := `{ \u0026#34;name\u0026#34;: \u0026#34;Jon\u0026#34;, \u0026#34;age\u0026#34; : 27, \u0026#34;location\u0026#34;: { \u0026#34;country\u0026#34;: \u0026#34;England\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;London\u0026#34; }, \u0026#34;hobbies\u0026#34;: [ \u0026#34;photography\u0026#34;, \u0026#34;writing\u0026#34;] }` var person map[string]interface{} err := json.Unmarshal([]byte(jsonObj), \u0026amp;person) if err != nil { log.Fatalf(\u0026#34;Unable to encode\u0026#34;) } for k, v := range person { switch v := v.(type) { case string: fmt.Println(k, v) case float64: fmt.Println(k, v) case map[string]interface{}: for i, ival := range v { fmt.Println(i, ival) } case []interface{}: for i, ival := range v { fmt.Println(i, ival) } default: fmt.Println(k, v) } } } Try it\nOutput\ncountry England city London 0 photography 1 writing name Jon age 27 Map is not indexed, so the order will always be different.\nStreaming Encoders and Decoders #The encoding/json provides Decoder and Encoder types to support the common operation of reading and writing streams of JSON data.\nfunc NewDecoder(r io.Reader) *Decoder func NewEncoder(w io.Writer) *Encoder In the below example,\nIt will read the stream of JSON data from an io.Reader removes the Age field from each object writes the objects to an io.Writer package main import ( \u0026#34;encoding/json\u0026#34; \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; \u0026#34;strings\u0026#34; ) func main() { jsonStream := `{\u0026#34;Name\u0026#34;:\u0026#34;Jon\u0026#34;, \u0026#34;Age\u0026#34;:27, \u0026#34;Location\u0026#34;: \u0026#34;London\u0026#34;} {\u0026#34;Name\u0026#34;:\u0026#34;Bruce\u0026#34;, \u0026#34;Age\u0026#34;:35, \u0026#34;Location\u0026#34;: \u0026#34;Gotham\u0026#34;}` reader := strings.NewReader(jsonStream) writer := os.Stdout dec := json.NewDecoder(reader) enc := json.NewEncoder(writer) for { var v map[string]interface{} if err := dec.Decode(\u0026amp;v); err != nil { log.Println(err) return } for k := range v { if k == \u0026#34;Age\u0026#34; { delete(v, k) } } if err := enc.Encode(\u0026amp;v); err != nil { log.Println(err) } } } Try it\nOutput\n{\u0026#34;Location\u0026#34;:\u0026#34;London\u0026#34;,\u0026#34;Name\u0026#34;:\u0026#34;Jon\u0026#34;} {\u0026#34;Location\u0026#34;:\u0026#34;Gotham\u0026#34;,\u0026#34;Name\u0026#34;:\u0026#34;Bruce\u0026#34;} 2009/11/10 23:00:00 EOF Code Walkthrough #reader := strings.NewReader(jsonStream) Create a type of io.Reader using the strings package.\ndec := json.NewDecoder(reader) enc := json.NewEncoder(writer) Create a new decoder which reads the data from the reader. Create a new encoder which writes the data to the writer.\nRest of the code is self-explanatory. Decode the arbitrary json in map[string]interface{}.\nConclusion #In this tutorial, we explored the json package. There are many other amazing functions provided by the encoding/json. Like MarshalIndent, it will indent the encoded json. Please check out the official website to learn more.\n","date":"March 23, 2020","permalink":"/posts/json-in-golang/","section":"Posts","summary":"When you start a project which interacts with the outer world, it requires data exchange.","title":"Json in Golang"},{"content":"","date":null,"permalink":"/tags/algorithm/","section":"Tags","summary":"","title":"algorithm"},{"content":"","date":null,"permalink":"/categories/algorithm/","section":"Categories","summary":"","title":"Algorithm"},{"content":"","date":null,"permalink":"/tags/js/","section":"Tags","summary":"","title":"js"},{"content":"","date":null,"permalink":"/categories/js/","section":"Categories","summary":"","title":"JS"},{"content":"Photo by Iñaki del Olmo on Unsplash\nData structures and Algorithms are the key skills for a software developer. Recently when I was preparing for a job change, learning sorting algorithms was not smooth.\nThe theory is simple and straight but its implementation is just the opposite.\nI think concept and implementation are inversely proportional. 🤔\nThere are many sorting algorithms like bubblesort, mergesort, quicksort etc. Among all, quicksort is one of the most popular sorting algorithms.\nToday, I\u0026rsquo;ll try to put all my learning while learning the quicksort.\nWhat is Quicksort? #Quicksort is one of the efficient sorting algorithms and the average complexity is O(n log n).\nThere are only 3 worst cases when its complexity is O(n^2).\nArray is sorted [2,3,4] Array is reverse sorted [4,3,2] All elements are identical in the array [4,4,4] Quicksort (sometimes called partition-exchange sort) is an efficient sorting algorithm. Developed by British computer scientist Tony Hoare in 1959 and published in 1961, it is still a commonly used algorithm for sorting. \u0026ndash; Wikipedia\nHow quicksort works? \u0026#x1f914; # Gif by Wikimedia\nQuicksort works on the divide and conquer algorithm.\nSelect any element in the array and this element is known as pivot.\nQuicksort is all about finding the correct position(index) of this pivot in the array.\nElements less than pivot must be in the left side of the pivot and elements greater than the pivot must be in the right side of the pivot.\nExample explains better \u0026#x1f609; #We have an array\n[3, 6, 2, 5, 4, 1, 7]; Any element can be selected as a pivot.\nFor this example, the first element of the array is the pivot \u0026#x2693;\nThe pivot is 3\npivot: 3, [3, 6, 2, 5, 4, 1, 7]; Elements less than pivot: 2, 1\nElements greater than pivot: 6, 5, 4, 7\nMove the elements less than pivot to the left side of pivot and elements greater than pivot to the right side of the pivot. Now, the correct position of the pivot (3) in the array is at index 2.\n[2, 1, 3, 6, 5, 4, 7]; Once, the pivot is in the correct position, divide the array. The elements on the left and the right side of the pivot will be the sub-array.\n[2, 1, 3, 6, 5, 4, 7]; ^ last pivot at the correct position [2, 1] [6, 5, 4, 7]; Sub-array 1: [2, 1]\nSub-array 2: [6, 5, 4, 7]\nSub-array 1 #Select the first element 2 as pivot.\npivot: 2, [2, 1]; Elements less than the pivot: 1\nElements greater than the pivot: No elements\nAgain, move the elements less than pivot to the left side of pivot and elements greater than pivot to the right side of the pivot. The correct position of the pivot (2) in the sub-array is at index 1.\n[1, 2]; Now, again divide the array. Elements on the left side and the right side will be sub-array.\nThere is no need to create a sub-array if there is only 1 element in the sub-array. It means pivot is already at the correct position in the array.\nSub-array 2 #Select the first element 6 as pivot.\npivot: 6, [6, 5, 4, 7]; Elements less than the pivot: 5, 4\nElements greater than the pivot: 7\nAgain, move the elements less than pivot to the left side of pivot and elements greater than pivot to the right side of the pivot. The correct position of the pivot (6) in the sub-array is at index 2.\n[5, 4, 6, 7]; Now, again divide the array. Elements on the left side and the right side of the pivot will be sub-array.\nSub-array 21: [5, 4]\nSub-array 22: [7]\nWe have to keep dividing the array by the time all the pivot will be on its correct index.\nAfter finding the correct position of pivot in sub-array 21\n[4, 5]; The final array with all its pivot at the correct position.\n[1, 2, 3, 4, 5, 6, 7]; Now, we understood the quicksort\u0026rsquo;s process, let\u0026rsquo;s implement it in javascript.\nJS implementation #The process has the following steps:\nSelect the pivot. The elements less than the pivot and the elements greater than the pivot, move them to the left side and the right side of the pivot respectively. Step 1 #Select the first element of the array as pivot.\n\u0026#x2757; Pivot can be any element of the array. Step 2 may vary to how the pivot is selected.\nStep 2 #To move the elements on the left and the right side of the pivot.\ni: Start from the leftmost element and its index is i.\nj: Start from the rightmost element or the last element of the array and its index is j.\nWhenever an element at index i is greater than the pivot and element at index j is smaller than the pivot, swap the elements at index i and j.\nIf, index i cross-index j then stop there and swap the element at j index with the pivot.\nThe index j is the sorted position of the pivot in the array.\nThe complete code is available on gist. js and golang implementation.\n\u0026#x1f4a1; Roll up your sleeves\nLine 33: Check the length of the array. If the length of the array is 1 or less than one, return the array as it is. It means the array is already in sorted order. Line 38: Select the first element as the pivot. Line 41: Initialize index i to 1 as it is the leftmost element of the array. Line 44: Initialize index j to arr.length-1, the last index of the array as it is the rightmost element of the array. Line 47: Iterate till index i do not cross-index j. Line 49: Iterate index i till value at index i is larger than the pivot. i will move away from the pivot, from index 1 to the last index of the array. Line 54: Iterate index j till value at index j is smaller than the pivot. j will move towards the pivot, from the last index of the array to the index 1. Line 61-65: If index i is less than j (didn\u0026rsquo;t cross each other), then swap the value at index i and at index j. Line 71-73:: Index j is the sorted position of the pivot. Swap the value at index j with the pivot. Now, the pivot is sorted in the array. The array on the left and the right side of the pivot is still unsorted. Create 2 sub-arrays. A left side of the pivot is one sub-array and right side of the pivot is another sub-array.\nLine 78: Use slice to create the left-side sub-array. slice(indexFrom, indexTo-1). The to range is not inclusive. If slice is slice(0,5), then its range is [0-4]. Line 82: Check if the left-subarray length is greater than 1. If true, then recursively call quicksort and pass left-subarray as an argument. Line 87: Use slice to create the right-side sub-array. Line 91: Check if the right-subarray length is greater than 1. If true, then recursively call quicksort and pass right-subarray as an argument. Line 100: Return the sorted array. Concat the left-subarray, the pivot element and the right-subarray. A recursive function is a function that calls itself until a predefined condition satisfy.\nRecursion in computer science is a method of solving a problem where the solution depends on solutions to smaller instances of the same problem. \u0026ndash; wikipedia\nReferences # Hackerearth Quicksort Algorithm By Abdul Bari ","date":"February 13, 2020","permalink":"/posts/understand-quicksort-the-easy-way/","section":"Posts","summary":"Photo by Iñaki del Olmo on Unsplash","title":"Understand Quicksort the easy way"},{"content":" Hi there, I am Shubham Kumar Chadokar, I am a Software Engineer 👓.\nThis is a documentation website of my learnings for my future self.\nI love to write articles and tutorials on Blockchain, Golang, Nodejs and Reactjs. My skill set is Blockchain (Ethereum, Hyperledger Fabric), Golang, Nodejs, Reactjs, Docker, Kubernetes.\nI love to do photography \u0026#x1f4f7; in my me time.\nI like philosophical and mythological novels \u0026#x1f4da;.\nMy favourites are Meluha and The Kite Runner.\nTalks #2022\nHow to Dockerize an Ethereum Decentralized Application @ DockerCon 2022 - Presentation 2020\nBuild a CLI in golang with Cobra @ Pune Gophers - Presentation July London Gophers @ London Gophers - Presentation Publications #freecodecamp\nHow to Write Your First Technical Book: Tools, Techniques, and Resources for First-time Developer Authors codesource.io\nCreate a CLI in golang with Cobra Build a CRUD application in Golang with PostgreSQL Learn How to use JSON in Golang Learn how to compare strings in the golang Building an offline To-Do App with React newline\nCreate your own Etherscan with React in 5 minutes medium\nMedium articles # Subscribe to my Newsletter to get my new articles directly in your mailbox.\n","date":"January 1, 1","permalink":"/about/","section":"schadokar.dev","summary":"Hi there, I am Shubham Kumar Chadokar, I am a Software Engineer 👓.","title":"About Me"}]